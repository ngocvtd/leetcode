# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12wx1P7ZUWIETovCt2r5thbDPsispa1dD
"""

!pip install ortools

from ortools.linear_solver import pywraplp

def solve_model(D):
    # khởi tạo một đối tượng
    s = pywraplp.Solver.CreateSolver('GLOP')
    n = len(D[0]) - 1

    # tính tổng các phần tử hàng cuối của ma trận
    B = sum([D[-1][j] for j in range(n)])

    # tạo ma trận có kích thước n x n có giá trị từ 0 đến B
    G = [[s.NumVar(0, B if D[i][j] else 0, "") for j in range(n)] for i in range(n)]


    for i in range(n):
        s.Add(D[i][-1] - D[-1][i] == sum(G[i][j] for j in range(n)) - sum(G[j][i] for j in range(n)))

    # hàm tính chi phí
    Cost = s.Sum(G[i][j] * D[i][j] for i in range(n) for j in range(n))

    # gọi phương thức để giải
    s.Minimize(Cost)

    # status solver
    rc = s.Solve()

    # giá trị tối ưu của hàm mục tiêu
    return rc, s.Objective().Value(), [[G[i][j].solution_value() for j in range(n)] for i in range(n)]
D = [
    [0, 0, 0, 0, 17, 10, 19, 0, 0],
    [23, 0, 0, 28, 0, 23, 0, 0, 0],
    [29, 0, 0, 0, 30, 25, 25, 0, 680],
    [0, 0, 0, 0, 17, 15, 19, 29, 0],
    [0, 16, 0, 0, 0, 0, 0, 0, 0],
    [22, 0, 0, 0, 25, 0, 0, 18, 540],
    [25, 29, 16, 0, 0, 22, 0, 0, 0],
    [0, 0, 30, 0, 10, 0, 27, 0, 0],
    [241, 0, 0, 164, 239, 0, 152, 424, 0]
]

solve_model(D)



from ortools.linear_solver import pywraplp

def solve_model(D):
  s = pywraplp.Solver.CreateSolver('GLOP')
  n = len(D[0]) - 1

  for j in range(n):
    B = sum(D[-1][j])

  G = []
  for i in range(n):
    row = []
    for j in range(n):
      if D[i][j] != 0:
        var = s.NumVar(0, B, "")
      else:
        var = s.NumVar(0, 0, "")
      row.append(var)
    G.append(row)

  for i in range(n):
        s.Add(D[i][-1] - D[-1][i] == sum(G[i][j] for j in range(n)) - sum(G[j][i] for j in range(n)))

from ortools.linear_solver import pywraplp
def solve_multi_layer_transshipment(D):
  s = pywraplp.Solver.CreateSolver('GLOP')

  # số lượng layers, nguồn, đích
  num_layers = len(D)
  num_sources = len(D[0])
  num_destinations = len(D[0][0])

  # tạo biến X[i][j] cho cặp nguồn-đích trong mỗi tâng
  G = [[[s.NumVar(0, s.infinity(), f"G[{i}][{j}][{k}]") for k in range(num_destinations)] for j in range(num_sources)] for i in range(num_layers)]

  # ràng buộc hàng chuyển đi từ nguồn đến tầng hiện tại đến các đích
  for i in range(num_layers):
    for j in range(num_sources):
        supply_constraint = s.Constraint(0, D[i][j][-1], f"Supply[{i}][{j}]")
        for k in range(num_destinations):
            supply_constraint.SetCoefficient(G[i][j][k], 1)

  # ràng  buộc hàng chuyển đến các đích từ nguồn tiếp theo
  for i in range(num_layers-1):
    for k in range(num_destinations):
        demand_constraint = s.Constraint(0, D[i+1][-1][k], f"Demand[{i+1}][{k}]")
        for j in range(num_sources):
            demand_constraint.SetCoefficient(G[i][j][k], 1)

  # hàm mục tiêu
  objective = s.Objective()
  for i in range(num_layers):
    for j in range(num_sources):
        for k in range(num_destinations):
            objective.SetCoefficient(G[i][j][k], D[i][j][k])
  objective.SetMinimization()

  s.Solve()
  # trích xuất giá trị X[i][j]
  solution = [[[G[i][j][k].solution_value() for k in range(num_destinations)] for j in range(num_sources)] for i in range(num_layers)]
  return solution

D = [
    [
        [0, 0, 0, 10, 0],
        [0, 0, 0, 15, 0],
        [0, 0, 0, 0, 25]
    ],
    [
        [20, 15, 0, 0, 0],
        [10, 0, 25, 30, 0],
        [0, 0, 0, 20, 25]
    ],
    [
        [0, 0, 0, 0, 20],
        [0, 0, 0, 10, 25],
        [0, 0, 0, 0, 15]
    ]
]

solve_multi_layer_transshipment(D)

D = [
    [
        [0, 0, 0, 10, 0],
        [0, 0, 0, 15, 0],
        [0, 0, 0, 0, 25]
    ],
    [
        [20, 15, 0, 0, 0],
        [10, 0, 25, 30, 0],
        [0, 0, 0, 20, 25]
    ],
    [
        [0, 0, 0, 0, 20],
        [0, 0, 0, 10, 25],
        [0, 0, 0, 0, 15]
    ]
]

print(D[0][1])

class Solution(object):
    def findMedianSortedArrays(self, nums1, nums2):
        """
        :type nums1: List[int]
        :type nums2: List[int]
        :rtype: float
        """
        merged_arr = nums1 + nums2

        n = len(merged_arr)
        for i in range(n-1):
            for j in range(n-1-i):
                if merged_arr[j] > merged_arr[j + 1]:
                    merged_arr[j], merged_arr[j + 1] = merged_arr[j + 1], merged_arr[j]

        if n % 2 == 0:
            return merged_arr[(n-1)//2]
        else:
            return (merged_arr[n//2] + merged_arr[(n//2)-1]) / 2

num1 = [1,2]
num2 = [3,4]
merged_arr = num1 + num2
n = len(merged_arr)
for i in range(n-1):
    for j in range(n-1-i):
        if merged_arr[j] > merged_arr[j + 1]:
            merged_arr[j], merged_arr[j + 1] = merged_arr[j + 1], merged_arr[j]
print(merged_arr)
print(merged_arr[(n-1)//2])
print((merged_arr[n//2] + merged_arr[(n//2)-1])//2)

heights = [2, 0, 2]
stack = []
n = len(heights)

for i in range(n):
    for j in range(n - i - 1):
        if heights[j] > heights[j + 1]:
            heights[j], heights[j + 1] = heights[j + 1], heights[j]

for i in range(len(heights)):
    stack.append(heights[i])

max_area = 0

for i in range(len(stack)):
    area = stack[i] * (len(stack) - i)
    max_area = max(max_area, area)

print(max_area)

matrix = [[1]]
if len(matrix) == 1:
  if matrix[0] == 0:
    print(0)
  else:
    print(1)

matrix = [[1, 0, 1, 0, 0],
           [1, 0, 1, 1, 1],
           [1, 1, 1, 1, 1],
           [1, 0, 0, 1, 0]]
heights = [0, 0, 0, 0, 0]