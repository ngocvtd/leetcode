# -*- coding: utf-8 -*-
"""multi_layer_transshipment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10FRtIb5otmFQ0Xq9bDewjtPsZJLFCAH1
"""

!pip install ortools

from ortools.linear_solver import pywraplp

def solve_model(D):

  # tạo một đối tượng mới
  s = pywraplp.Solver.CreateSolver('GLOP')

  # số lượng layer i
  num_layer = len(D)

  # số lượng nguồn j
  num_sources = len(D[0])

  # số đích đến k
  num_destinations = len(D[0][0])

  # tạo ma trận X[i][j][k] cho mỗi cặp nguồn - đích
  X = [[[s.NumVar(0, s.infinity(), f"G[{i}][{j}][{k}]") for k in range(num_destinations)] for j in range(num_sources)] for i in range(num_layer)]

  # ràng buộc nguồn (tổng lượng hàng hóa chuyển đi từ mỗi nguồn không vượt quá lượng hàng hóa có sẵn tại nguồn đó)
  for i in range(num_layer):
    for j in range(num_sources):
        s.Add(s.sum(X[i][j][k] for k in range(num_destinations)) <= D[i][j][0])

  # ràng buộc đích (tổng lượng hàng hóa nhận được tại mỗi đích bằng tổng lượng hàng hóa chuyển đến đích đó từ các nguồn)
  for i in range(num_layer):
    for j in range(num_sources):
      s.Add(s.Sum(X[i][j][k] for k in range(num_destinations)) == D[i][0][j])

  # ràng buộc tầng (hàng hóa chuyển đi từ mỗi nguồn không vượt quá lượng hàng hóa có sẵn tại nguồn đó ở tầng trước đó)
  for i in range(num_layer):
      for k in range(num_destinations):
          for j in range(num_sources):
              s.Add(X[(i, j, k)] <= D[i][j][k+1])

  # Chạy solver
  status = s.Solve()

  # Kiểm tra trạng thái giải quyết

from ortools.linear_solver import pywraplp

def solve_model(D):

  # tạo 1 đối tượng mới
  s = pywraplp.Solver.CreateSolver('GLOP')

  # số layer k
  num_layer = len(D)

  # số nguồn i
  num_sources = len(D[0])

  # số đích j
  num_des = len(D[0][0])

  # tạo biến quyết định số lượng hàng hóa vận chuyển từ nguồn i đích j trong tầng k
  X = [[[s.NumVar(0, s.infinity(), f'X_{k}_{i}_{j}') for j in range(num_des)] for i in range(num_sources)] for k in range(num_layer)]

  # ràng buộc từ nguồn đến layer đầu tiên
  for i in range(num_layer):
    outgoing_flows = sum(X[0][i][j] for j in range(num_des))
    s.Add(outgoing_flows == D[0][i])

  # ràng buộc từu layer cuối đến đích
  for j in range(num_des):
        incoming_flows = sum(X[num_layer-1][i][j] for i in range(num_sources))
        s.Add(incoming_flows == D[num_layer-1][j])

  # Tạo ràng buộc cân bằng tại mỗi layer trung gian
  for k in range(1, num_layer-1):
      for i in range(num_sources):
        for j in range(num_des):
          incoming_flows = sum(X[k-1][m][j] for m in range(num_sources))
          outgoing_flows = sum(X[k][i][n] for n in range(num_des))
          s.Add(incoming_flows == outgoing_flows)

  # hàm chi phí
  total_cost = sum(X[k][i][j] * D[k][i][j] for k in range(num_layer) for i in range(num_sources) for j in range(num_des))

  # tối ưu chi phí
  s.Minimize(total_cost)

  rc = s.Solve()

  return rc, s.Objective().Value(), [[[X[k][i][j].Value() for k in range(num_layer)] for i in range(num_sources)] for j in range(num_des)]

from ortools.linear_solver import pywraplp

def solver_model(a, x, y):

  # tạo đối tượng
  s = pywraplp.Solver.CreateSolver('GLOP')

  # tạo biến n1 & n2
  n1 = s.IntVar(0, s.infinity(), 'n1')
  n2 = s.IntVar(0, s.infinity(), 'n2')

  # ràng buộc
  s.Add(a >= n1 * x + n2 * y)

  # tạo hàm mục tiêu
  objective = s.Objective()
  objective.SetCoefficient(n1, 1)
  objective.SetCoefficient(n2, 1)
  objective.SetMaximization()

  # Giải quyết mô hình
  s.Solve()

  # Trả về giá trị tối ưu của n1 và n2
  return n1.solution_value(), n2.solution_value()

a = 20
x = 3
y = 5


solve_model(a, x, y)