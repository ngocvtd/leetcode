# -*- coding: utf-8 -*-
"""transhipment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eCFcdQMO0SwRXKroezx0hnSrimN6PqLw
"""

!pip install ortools

from ortools.linear_solver import pywraplp
def newSolver(name,integer=False):
  return pywraplp.Solver(name,\
                         pywraplp.Solver.CBC_MIXED_INTEGER_PROGRAMMING \
                         if integer else \
                         pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)

def SolVal(x):
  if type(x) is not list:
    return 0 if x is None \
      else x if isinstance(x,(int,float)) \
           else x.SolutionValue() if x.Integer() is False \
                else int(x.SolutionValue())
  elif type(x) is list:
    return [SolVal(e) for e in x]

def ObjVal(x):
  return x.Objective().Value()

def pairs(tuple, accum=[]):
  if len(tuple)==0:
    return accum
  else:
    accum.extend((tuple[0],e) for e in tuple[1:])
    return pairs(tuple[1:],accum)

# from my_or_tools import ObjVal, SolVal, newSolver

# def k_out_of_n(solver,k,x,rel='=='):
#   n = len(x)
#   binary = sum(x[i].Lb()==0 for i in range(n)) == n and \
#            sum(x[i].Ub()==1 for i in range(n)) == n
#   if binary:
#     l = x
#   else:
#     l = [solver.IntVar(0,1,'') for i in range(n)]
#     for i in range(n):
#       if x[i].Ub() > 0:
#         solver.Add(x[i] <= x[i].Ub()*l[i])
#       else:
#         solver.Add(x[i] >= x[i].Lb()*l[i])
#   S = sum(l[i] for i in range(n))
#   if rel == '==' or rel == '=':
#     solver.Add(S == k)
#   elif rel == '>=':
#     solver.Add(S >= k)
#   else:
#     solver.Add(S <= k)
#   return l

# def sosn(solver,k,x,rel='<='):
#   def sosnrecur(solver,k,l):
#     n = len(l)
#     d = [solver.IntVar(0,1,'') for _ in range(n-1)]
#     for i in range(n):
#       solver.Add(l[i] <= sum(d[j] \
#         for j in range(max(0,i-1),min(n-2,i+1))))
#     solver.Add(k == sum(d[i] for i in range(n-1)))
#     return d if k <= 1 else [d,sosnrecur(solver,k-1,d)]
#   n = len(x)
#   if 0 < k < n:
#     l = k_out_of_n(solver,k,x,rel)
#     return l if k <= 1 else [l,sosnrecur(solver,k-1,l)]

# from ortools.linear_solver import pywraplp
# def bounds_on_box(a,x,b):
#   Bounds,n = [None,None],len(a)
#   s = pywraplp.Solver('Box',pywraplp.Solver.GLOP_LINEAR_PROGRAMMING)
#   xx = [s.NumVar(x[i].Lb(), x[i].Ub(),'') for i in range(n)]
#   S = s.Sum([-b]+[a[i]*xx[i] for i in range(n)])
#   s.Maximize(S)
#   rc = s.Solve()
#   Bounds[1] = None if rc != 0 else ObjVal(s)
#   s.Minimize(S)
#   s.Solve()
#   Bounds[0] = None if rc != 0 else ObjVal(s)
#   return Bounds

# def reify_force(s,a,x,b,delta=None,rel='<=',bnds=None):
#   # delta == 1 ---> a*x <= b
#   n = len(a)
#   if delta is None:
#     delta = s.IntVar(0,1,'')
#   if bnds is None:
#     bnds = bounds_on_box(a,x,b)
#   if rel in ['<=','==']:
#     s.Add(sum(a[i]*x[i] for i in range(n))<=b+bnds[1]*(1-delta))
#   if rel in ['>=','==']:
#     s.Add(sum(a[i]*x[i] for i in range(n))>=b+bnds[0]*(1-delta))
#   return delta

# def reify_raise(s,a,x,b,delta=None,rel='<=',bnds=None,eps=1):
#   # a*x <= b ---> delta == 1
#   n = len(a)
#   if delta is None:
#     delta = s.IntVar(0,1,'')
#   if bnds is None:
#     bnds = bounds_on_box(a,x,b)
#   if rel == '<=':
#     s.Add(sum(a[i]*x[i] for i in range(n)) \
#           >= b+bnds[0]*delta+eps*(1-delta))
#   if rel == '>=':
#     s.Add(sum(a[i]*x[i] for i in range(n)) \
#           <= b+bnds[1]*delta-eps*(1-delta))
#   elif rel == '==':
#     gm = [s.IntVar(0,1,'') for _ in range(2)]
#     s.Add(sum(a[i]*x[i] for i in range(n)) \
#           >= b+bnds[0]*gm[0]+eps*(1-gm[0]))
#     s.Add(sum(a[i]*x[i] for i in range(n)) \
#           <= b+bnds[1]*gm[1]-eps*(1-gm[1]))
#     s.Add(gm[0] + gm[1] - 1 == delta)
#   return delta

# def reify(s,a,x,b,d=None,rel='<=',bs=None,eps=1):
#   # d == 1 <---> a*x <= b
#   return reify_raise(s,a,x,b,reify_force(s,a,x,b,d,rel,bs),rel,bs,eps)

# def maximax(s,a,x,b):
#   n = len(a)
#   d = [bounds_on_box(a[i],x,b[i]) for i in range(n)]
#   zbound = [min(d[i][0] for i in range(n)), max(d[i][1] \
#            for i in range(n))]
#   z = s.NumVar(zbound[0],zbound[1],'')
#   delta = [reify(s,a[i]+[-1],x+[z],b[i],None,'==') \
#           for i in range(n)]
#   k_out_of_n(s,1,delta)
#   s.Maximize(z)
#   return z,delta

from random import randint
def gen_data(n,zap=True):
    R,Cap=[],[]
    S,D=0,0
    for i in range(n):
        RR=[]
        for j in range(n):
            if zap:
                yesno=randint(0,1)
            else:
                yesno=1
            if i != j and (i<j or randint(0,1)*R[j][i]==0):
                RR.append(yesno*randint(10,30))
            else:
                RR.append(0)
        T = (0 if i == n-1 else randint(0,1)*randint(0,1))*randint(500,700)
        RR.append(T)
        R.append(RR)
        S += T
    A = S/n
    RR = []
    for i in range(n-1):
        if zap:
            yesno=1-(randint(0,1)*randint(0,1))
        else:
            yesno=1
        T = (1 if R[i][-1]==0 else 0)*yesno*randint(int(0.95*A), int(1.9*A))
        RR.append(T)
        D += T
    # Need to ensure balance
    T = S-D
    RR.append(T)
    D += T
    RR.append(0)
    R.append(RR)
    return R

# from my_or_tools import ObjVal, SolVal, newSolver

cost_matrix = gen_data(10,zap=True)
cost_matrix = np.array(cost_matrix)
cost_matrix

import numpy as np

supply = cost_matrix[:,-1]
demand = cost_matrix[-1,:]
supply = supply.tolist()
demand = demand.tolist()

def solve_model(cost_matrix):

    # khởi tạo một đối tượng
    solver= newSolver('Transshipment problem')

    n = len(cost_matrix[0])-1

    # tính tổng các phần tử trong hàng cuối cùng của ma trận D
    B = sum([demand[j] for j in range(n)])

    #Tạo một ma trận 2D G có kích thước n x n bằng cách sử dụng phương thức NumVar của solver s. \
    # Các phần tử của ma trận được khởi tạo là các biến không âm, có giá trị từ 0 đến B nếu phần tử tương ứng của ma trận D khác 0, \
    # và khởi tạo là 0 nếu phần tử tương ứng của ma trận D là 0.
    G = []
    for i in range(n):
        temp = []
        for j in range(n):
            if cost_matrix[i][j] != 0:
                temp.append(0)
            else:
                var_name = 'X[{},{}]'.format(i, j)
                temp.append(solver.NumVar(0, B if cost_matrix[i][j] != 0 else 0, var_name))
        G.append(temp)




    # G = [[solver.NumVar(0,B if cost_matrix[i][j] != 0  else 0,'') for j in range(n)] for i in range(n)]

    for i in range(n):
        # thêm ràng buộc cho từng
        solver.Add(supply[i] - demand[i] ==  sum(G[i][j] for j in range(n)) -   sum(G[j][i]  for j in range(n)))

    # Tính hàm chi phí
    Cost=solver.Sum(G[i][j]*cost_matrix[i][j] for i in range(n)for j in range(n))

    # gọi phương thúc để giải
    solver.Minimize(Cost)

    # status solver
    rc = solver.Solve()

    # Giá trị tối ưu (ObjVal(s)) của mục tiêu chi phí.
    #
    return rc,ObjVal(solver),SolVal(G)
a,b,c = solve_model(cost_matrix)

a,b,c = solve_model(D)
c